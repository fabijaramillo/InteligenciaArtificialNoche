<!DOCTYPE html>
<!-- saved from url=(0093)file:///C:/Users/TUF%20A15/Desktop/inteligencia%20artificial/InteligenciaArtificialNoche.html -->
<html lang="es"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Webinar sobre Ciberseguridad, Inteligencia Artificial y Computación en la Nube. Aprendizajes clave y aplicaciones actuales.">
    <title>Ciberseguridad, Inteligencia Artificial, Computación en la Nube</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 0; }
        header, footer { background-color: #f4f4f4; padding: 1em; text-align: center; }
        h1, h2 { color: #333; margin: 0.5em 0; }
        h1 { font-size: 2em; border-bottom: 2px solid #333; padding-bottom: 0.5em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #333; padding-bottom: 0.5em; }
        p { margin: 0.5em 0; }
        ul { margin: 1em 0; padding-left: 1.5em; }
        footer p { font-size: 0.9em; }
        table {
            width: 50%;
            border-collapse: collapse;
            margin: 20px auto;
        }
        th, td {
            border: 1px solid #000;
            padding: 10px;
            text-align: center;
        }
        th { background-color: #f2f2f2; }
        .image-container {
            display: flex;
            justify-content: center;
            gap: 10px; /* Espacio entre imágenes */
            margin: 20px 0;
        }
        img {
            max-width: 120px; /* Tamaño aumentado */
            height: auto; /* Mantiene la proporción */
            margin: 10px;
        }
        a {
            color: #007BFF;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <header>
        <h1>Clase 15 de Agosto 2024</h1>
    </header>
    
    <section>
        <h2>Ciberseguridad, Inteligencia Artificial y Computación en la Nube</h2>
        <p>
            En el webinar sobre Ciberseguridad, Inteligencia Artificial y Computación en la Nube se aprendió que la ciberseguridad se utiliza para prevenir 
            ataques de malware y phishing, los cuales son amenazas que atacan sin el consentimiento de las personas con el fin de robar información.
        </p>
        <p>
            Se mencionó que se emplea mucho la IA y la computación en la nube para reducir costos de administración y agilizar la gestión de procesos, 
            tales como transacciones, retiros y transferencias de dinero. De esta manera, se propone el uso adecuado de las nuevas tecnologías 
            para garantizar la seguridad de las personas y cómo estas manejan su dinero.
        </p>
        <p>
            Cuando otorgamos permisos a páginas o plataformas, se debe tener en cuenta si realmente deseamos dar acceso al tratamiento de nuestros datos personales. 
            Esta regulación está definida en la Ley de Protección de Datos Personales o Ley 1581 de 2012, la cual reconoce y protege el derecho que tienen todas las personas 
            a conocer, actualizar y rectificar la información que se haya recogido sobre ellas.
        </p>
        <p>
            Para más información, visita el siguiente enlace: 
            <a href="https://fabijaramillo.github.io/InteligenciaArtificialNoche/" target="_blank">https://fabijaramillo.github.io/InteligenciaArtificialNoche/</a>.
        </p>
    </section>
    
    <section>
        <h1>Clase 22 de Agosto 2024</h1>
        <p>
            En la clase del 22 de agosto, se profundizó en el tema de la inteligencia artificial. Se abordaron conceptos clave y aplicaciones actuales, así como 
            las implicaciones éticas y prácticas de la IA en diversos sectores.
        </p>
    </section>
    
    <section>
        <h2>¿Qué es la Inteligencia Artificial?</h2>
        <p>
            La inteligencia artificial (IA) es un campo de la informática que se centra en desarrollar sistemas y tecnologías capaces de realizar tareas que normalmente requieren 
            inteligencia humana, como aprender de experiencias y comprender el lenguaje natural.
        </p>
    </section>

    <section>
        <h2>Punto 3: Tabla de Laberintos</h2>
        <table>
            <thead>
                <tr>
                    <th></th>
                    <th>DFS</th>
                    <th>BFS</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Laberinto 1</td>
                    <td>425</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>Laberinto 2</td>
                    <td>425</td>
                    <td>2062</td>
                </tr>
            </tbody>
        </table>
        
        <div class="image-container">
            <img src="./index_files/ima3.jpeg" alt="Diagrama del laberinto 1">
            <img src="./index_files/m2.PNG" alt="Diagrama del laberinto 2">
            <img src="./index_files/maze.PNG" alt="Diagrama del laberinto 3">
        </div>
    </section>

    <section>
        <h2>Código de lógica con comentarios</h2>
        <pre><code>
import itertools  # Importa el módulo itertools, que proporciona funciones para crear iteradores.

class Sentence():  # Define la clase base para oraciones lógicas.
    """
    Clase base para representar una oración lógica.
    """

    def evaluate(self, model):  # Método para evaluar la oración lógica.
        """
        Evalúa la oración lógica utilizando un modelo.
        En este caso, es un método abstracto que será implementado en clases derivadas.
        """
        raise Exception("nada que evaluar")  # Lanza una excepción si no se implementa.

    def formula(self):  # Método que devuelve la representación en cadena de la fórmula.
        """
        Devuelve una representación de la fórmula lógica en forma de cadena de texto.
        """
        return ""  # Devuelve una cadena vacía como representación por defecto.

    def symbols(self):  # Método que devuelve todos los símbolos presentes en la oración lógica.
        """
        Devuelve una lista de símbolos lógicos presentes en la oración.
        """
        return []  # Devuelve una lista vacía como representación por defecto.


        <h1>PARCIAL PUNTO 5 Comentarios sobre el código logic.py</h1>
        <pre><code>
    import itertools  # Importa el módulo itertools, que proporciona funciones para crear iteradores.
    
    class Sentence():  # Define la clase base para oraciones lógicas.
        """
        Clase base para representar una oración lógica.
        """
    
        def evaluate(self, model):  # Método para evaluar la oración lógica.
            """
            Evalúa la oración lógica utilizando un modelo.
            En este caso, es un método abstracto que será implementado en clases derivadas.
            """
            raise Exception("nada que evaluar")  # Lanza una excepción si no se implementa.
    
        def formula(self):  # Método que devuelve la representación en cadena de la fórmula.
            """
            Devuelve una representación de la fórmula lógica en forma de cadena de texto.
            """
            return ""  # Devuelve una cadena vacía como representación por defecto.
    
        def symbols(self):  # Método que devuelve todos los símbolos presentes en la oración lógica.
            """
            Devuelve un conjunto de todos los símbolos presentes en la oración lógica.
            """
            return set()  # Devuelve un conjunto vacío, ya que no hay símbolos en la clase base.
    
        @classmethod
        def validate(cls, sentence):  # Método de clase para validar si un objeto es una instancia de Sentence.
            """
            Valida si un objeto es una instancia de la clase Sentence.
            """
            if not isinstance(sentence, Sentence):  # Verifica si 'sentence' es una instancia de Sentence.
                raise TypeError("debe ser una oración lógica")  # Lanza una excepción si no es válida.
    
        @classmethod
        def parenthesize(cls, s):  # Método que coloca paréntesis en una expresión si no los tiene ya.
            """
            Coloca paréntesis en una expresión si no los tiene ya.
            """
            def balanced(s):  # Función interna que verifica si una cadena tiene paréntesis balanceados.
                """
                Verifica si una cadena tiene paréntesis balanceados.
                """
                count = 0  # Contador para los paréntesis.
                for c in s:  # Itera sobre cada carácter en la cadena.
                    if c == "(":  # Si encuentra un paréntesis de apertura.
                        count += 1  # Incrementa el contador.
                    elif c == ")":  # Si encuentra un paréntesis de cierre.
                        if count &lt;= 0:  # Verifica si hay un paréntesis de cierre sin par de apertura.
                            return False  # Devuelve falso si no están balanceados.
                        count -= 1  # Decrementa el contador.
                return count == 0  # Devuelve verdadero si todos los paréntesis están balanceados.
    
            if not len(s) or s.isalpha() or (  # Si la cadena está vacía, es alfabética, o ya tiene paréntesis balanceados.
                s[0] == "(" and s[-1] == ")" and balanced(s[1:-1])
            ):
                return s  # Devuelve 's' sin cambios si ya está balanceado.
            else:
                return f"({s})"  # Agrega paréntesis alrededor de 's'.
    
    # Aquí comienzan las clases para representar diferentes operadores lógicos.
    
    class Symbol(Sentence):  # Clase que representa un símbolo lógico.
        """
        Representa un símbolo lógico.
        """
    
        def __init__(self, name):  # Constructor que inicializa el nombre del símbolo.
            self.name = name  # Almacena el nombre del símbolo.
    
        def __eq__(self, other):  # Método para comparar dos símbolos.
            return isinstance(other, Symbol) and self.name == other.name  # Compara si son del mismo tipo y tienen el mismo nombre.
    
        def __hash__(self):  # Método para obtener un hash del símbolo.
            return hash(("symbol", self.name))  # Devuelve un hash basado en el nombre del símbolo.
    
        def __repr__(self):  # Método para representar el símbolo como una cadena.
            return self.name  # Devuelve el nombre del símbolo.
    
        def evaluate(self, model):  # Método para evaluar el valor del símbolo en un modelo dado.
            """
            Evalúa el valor del símbolo en un modelo dado.
            """
            try:
                return bool(model[self.name])  # Devuelve el valor del símbolo del modelo.
            except KeyError:
                raise EvaluationException(f"variable {self.name} no está en el modelo")  # Lanza excepción si el símbolo no está en el modelo.
    
        def formula(self):  # Método que devuelve la fórmula del símbolo.
            return self.name  # Devuelve el nombre del símbolo como su fórmula.
    
        def symbols(self):  # Método que devuelve el conjunto que contiene solo este símbolo.
            """
            Devuelve el conjunto que contiene solo este símbolo.
            """
            return {self.name}  # Devuelve un conjunto con solo este símbolo.
    
    # Similarmente, las clases Not, And, Or, Implication y Biconditional seguirán este patrón.
    # Implementan métodos para evaluar, representar y manejar símbolos lógicos.
    
    class Not(Sentence):  # Clase que representa una negación lógica.
        """
        Representa una negación lógica.
        """
        def __init__(self, operand):  # Constructor que inicializa el operando.
            Sentence.validate(operand)  # Valida que el operando sea una oración lógica.
            self.operand = operand  # Almacena el operando.
    
        def __eq__(self, other):  # Método para comparar dos negaciones.
            return isinstance(other, Not) and self.operand == other.operand  # Compara si son del mismo tipo y tienen el mismo operando.
    
        def __hash__(self):  # Método para obtener un hash de la negación.
            return hash(("not", hash(self.operand)))  # Devuelve un hash basado en el operando.
    
        def __repr__(self):  # Método para representar la negación como una cadena.
            return f"Not({self.operand})"  # Devuelve la representación de la negación.
    
        def evaluate(self, model):  # Método para evaluar la negación.
            """
            Evalúa la negación, invirtiendo el valor del operando.
            """
            return not self.operand.evaluate(model)  # Devuelve el valor invertido del operando.
    
        def formula(self):  # Método que devuelve la fórmula de la negación.
            return "¬" + Sentence.parenthesize(self.operand.formula())  # Devuelve la fórmula precedida por el símbolo de negación.
    
        def symbols(self):  # Método que devuelve los símbolos del operando.
            return self.operand.symbols()  # Devuelve los símbolos del operando.
    
    # Las clases And, Or, Implication y Biconditional seguirán un patrón similar.
    # Cada una representará su respectiva operación lógica.
    
    # Por último, la función model_check sirve para comprobar implicaciones lógicas entre el conocimiento y la consulta.
        </code></pre>


        <h1>PARCIAL PUNTO 6 Comentarios sobre el código estudianteunimayorJARAMILLO.py</h1>
        <pre><code>
            rain = False         # True si llueve, False si no
            bbc = False          # True si los estudiantes visitaron BBC
            unimayor = True      # True si los estudiantes visitaron Unimayor
            
            # Conocimiento:
            # Si no llueve, los estudiantes visitan BBC
            if not rain:
                bbc = True
            
            # Los estudiantes visitaron BBC o Unimayor pero no ambos (XOR)
            bbc_unimayor = (bbc or unimayor) and not (bbc and unimayor)
            
            # Los estudiantes visitaron Unimayor
            unimayor = True  # Afirmación directa
            
            # Inferencia sobre BBC y el clima
            print("¿Los estudiantes visitaron BBC?", bbc)
            print("¿Llovió?", rain)
        </code></pre>
    
    
        </code></pre>
    </section>

    <footer>
        <p>Derechos reservados © 2024</p>
    </footer>


</body></html>